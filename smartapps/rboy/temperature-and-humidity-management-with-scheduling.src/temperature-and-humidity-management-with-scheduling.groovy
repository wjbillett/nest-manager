/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "01.04.00"
}

/**
*  Humidity and Extreme Temperature Management
*
* Copyright RBoy, redistribution of code is not allowed without permission
* 2016-11-5 - Added support for automatic code update notifications and fixed an issue with sms
* 2016-8-17 - Added support for ST contact address book
* 2016-5-19 - If end time is after start time then assume the end time is next day
* 2016-5-15 - Notify use if timezone/location is missing in setup
* 2016-1-19 - Added scheduling options, also when in a non operating mode, it will not turn on devices but will turn off as a safetly measure
* 2016-1-12 - Added notifications
* 2016-1-11 - Initial version
*/
definition(
    name: "Temperature and Humidity Management with Scheduling",
    namespace: "rboy",
    author: "RBoy",
    description: "Use your HVACs, fans, heaters and dehumidifiers to control the humidity and extreme temperatures",
    category: "Green Living",
    iconUrl: "https://s3.amazonaws.com/smartapp-icons/GreenLiving/Cat-GreenLiving.png",
    iconX2Url: "https://s3.amazonaws.com/smartapp-icons/GreenLiving/Cat-GreenLiving@2x.png",
    iconX3Url: "https://s3.amazonaws.com/smartapp-icons/GreenLiving/Cat-GreenLiving@3x.png")

preferences {
    page(name: "mainPage")
}

def mainPage() {
    dynamicPage(name: "mainPage", title: "Humidity and Temperature Management v${clientVersion()}", install: true, uninstall: true) {    
        TimeZone timeZone = location.timeZone
        if (!timeZone) {
            timeZone = TimeZone.getDefault()
            log.error "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
            sendPush "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
            section("INVALID HUB LOCATION") {
                paragraph "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
            }
        }

        section("High temperature management", hidden: (highTemperatureSensor ? false : true), hideable: true) {
            input "highTemperatureSensor", "capability.temperatureMeasurement", title: "High temperature sensor", required: false, multiple:false, submitOnChange: true
            if (highTemperatureSensor) {
                input "highTemp", "number", title: "If the temperature rises above...", required: true
                input "thermostatsCool", "capability.thermostat", title: "Turn on these HVAC(s)...", required: false, multiple:true
                input "fans", "capability.switch", title: "Turn on these coolers(s)", required: false, multiple:true
            }
        }

        section("Low Temperature management", hidden: (lowTemperatureSensor ? false : true), hideable: true) {
            input "lowTemperatureSensor", "capability.temperatureMeasurement", title: "Low temperature sensor", required: false, multiple:false, submitOnChange: true
            if (lowTemperatureSensor) {
                input "lowTemp", "number", title: "If the temperature falls below...", required: true
                input "thermostatsHeat", "capability.thermostat", title: "Turn on these HVAC(s)...", required: false, multiple:true
                input "heaters", "capability.switch", title: "Turn on these heaters(s)...", required: false, multiple:true
            }
        }

        section("Humidity management", hidden: (humiditySensor ? false : true), hideable: true) {
            input "humiditySensor", "capability.relativeHumidityMeasurement", title: "Humidity sensor", required: false, multiple:false, submitOnChange: true
            if (humiditySensor) {
                input "highHumidity", "number", title: "If the humidity rises above (%)...", required: true
                input "thermostatsDehumidify", "capability.thermostat", title: "Turn on these HVAC(s)...", required: false, multiple:true
                input "dehumidifiers", "capability.switch", title: "Turn on these dehumidifiers(s)", required: false, multiple:true
            }
        }

        for (i in 0..2) { // 3 Schedules allowed
            def priorUserDayOfWeek = settings."userDayOfWeekA${i}"
            def priorUserStartTime = settings."userStartTimeA${i}"
            def priorUserEndTime = settings."userEndTimeA${i}"

            section("Operating Schedule ${i + 1} (optional)", hidden: (settings."userDayOfWeekA${i}" ? false : true), hideable: true) {
                input "userStartTimeA${i}", "time", title: "Start Time", required: false
                input "userEndTimeA${i}", "time", title: "End Time", required: false
                input name: "userDayOfWeekA${i}",
                    type: "enum",
                    title: "Which day of the week?",
                    required: false,
                    multiple: true,
                    options: [
                        'All Week',
                        'Monday to Friday',
                        'Saturday & Sunday',
                        'Monday',
                        'Tuesday',
                        'Wednesday',
                        'Thursday',
                        'Friday',
                        'Saturday',
                        'Sunday'
                    ],
                    defaultValue: priorUserDayOfWeek
            }
        }

        section("Operating Modes (optional)", hidden: (modeMonitor ? false : true), hideable: true) {
            input name: "modeMonitor", title: "Enable operation only when in these mode(s)", type: "mode", required: false, multiple: true
        }

        section("Notification Options", hidden: ((recipients || sms || push) ? false : true), hideable: true) {
            input("recipients", "contact", title: "Send notifications to (optional)", multiple: true, required: false) {
                paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '+'. E.g. 5551234567+4447654321"
                input name: "sms", title: "Send SMS notification to (optional):", type: "phone", required: false
                input "push", "bool", title: "Send Push Notification", required: false, defaultValue: true
            }
        }
        section() {
            label title: "Assign a name for this SmartApp (optional)", required: false
            input name: "disableUpdateNotifications", title: "Don't check for new versions of the app", type: "bool", required: false
        }
    }
}

def installed()
{
    log.debug "Installed"

    subscribeToEvents()
}

def updated()
{
    log.debug "Updated"

    unsubscribe()
    unschedule()
    subscribeToEvents()
}

def subscribeToEvents() {
    log.debug "Initialized with $settings"

    subscribe(highTemperatureSensor, "temperature", highTemperatureHandler)
    subscribe(lowTemperatureSensor, "temperature", lowTemperatureHandler)
    subscribe(humiditySensor, "humidity", humidityHandler)

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("0 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm
}

def highTemperatureHandler(evt) {
    log.debug "High temperature sensor change notification, name: ${evt.name}, value: ${evt.value}"

    // A/C
    def threshold = 1 // Minimum difference in temperatures to make things happen
    def locationScale = getTemperatureScale()
    def maxTemp
    def minTemp
    if (locationScale == "C") {
        minTemp = 10 // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxTemp = 32 // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        log.trace "Location is in Celsius, MaxTemp $maxTemp, MinTemp $minTemp for thermostat"
    } else {
        minTemp = 50 // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxTemp = 90 // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        log.trace "Location is in Farenheit, MaxTemp $maxTemp, MinTemp $minTemp for thermostat"
    }

    if (highTemperatureSensor) {
        def currentTemp = highTemperatureSensor.currentTemperature
        log.trace("High Temp Sensor Current Temp: $currentTemp°")

        if ((currentTemp - highTemp) >= threshold) { // Turn cool on
            if (modeMonitor && !modeMonitor.contains(location.mode)) { // Empty means all modes, only turn on if we are in a supported mode (turn off to avoid over heating/cooling even if not in active mode)
                log.warn "Current mode ${location.mode} is not in the list of operating modes $modeMonitor, skipping turning on"
                return
            }

            if (!checkSchedule(0, "A") && !checkSchedule(1, "A") && !checkSchedule(2, "A")) { // Check if we are within operating Schedule to turn things on
                log.warn "Out of operating schedules, skipping turning on"
                return
            }

            if (thermostatsCool) {
                thermostatsCool.setCoolingSetpoint(minTemp) // Set to cool
                log.info "HVAC ON, set cool: ${minTemp}"
                sendMessageNotification("High temperature $currentTemp, turning on HVAC cool")
            }
            if (fans) {
                fans.on()
                log.info "Cooling fans on"
                sendMessageNotification("High temperature $currentTemp, turning on fans")
            }
        }
        else if ((highTemp - currentTemp) >= threshold) { // Turn cool off
            if (thermostatsCool) {
                thermostatsCool.setCoolingSetpoint(maxTemp) // Disable
                log.info "HVAC OFF, set cool: ${maxTemp}"
                sendMessageNotification("Temperature reduced $currentTemp, turning off HVAC")
            }
            if (fans) {
                fans.off()
                log.info "Cooling fans off"
                sendMessageNotification("Temperature reduced $currentTemp, turning off fans")
            }
        }
    }
}

def lowTemperatureHandler(evt) {
    log.debug "Low temperature sensor change notification, name: ${evt.name}, value: ${evt.value}"

    // Heater
    def threshold = 1 // Minimum difference in temperatures to make things happen
    def locationScale = getTemperatureScale()
    def maxTemp
    def minTemp
    if (locationScale == "C") {
        minTemp = 10 // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxTemp = 32 // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        log.trace "Location is in Celsius, MaxTemp $maxTemp, MinTemp $minTemp for thermostat"
    } else {
        minTemp = 50 // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxTemp = 90 // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        log.trace "Location is in Farenheit, MaxTemp $maxTemp, MinTemp $minTemp for thermostat"
    }

    if (lowTemperatureSensor) {
        def currentTemp = lowTemperatureSensor.currentTemperature
        log.trace("Low Temp Sensor Current Temp: $currentTemp°")

        if ((lowTemp - currentTemp) >= threshold) { // Turn heat on
            if (modeMonitor && !modeMonitor.contains(location.mode)) { // Empty means all modes, only turn on if we are in a supported mode (turn off to avoid over heating/cooling even if not in active mode)
                log.warn "Current mode ${location.mode} is not in the list of operating modes $modeMonitor, skipping turning on"
                return
            }

            if (!checkSchedule(0, "A") && !checkSchedule(1, "A") && !checkSchedule(2, "A")) { // Check if we are within operating Schedule to turn things on
                log.warn "Out of operating schedules, skipping turning on"
                return
            }

            if (thermostatsHeat) {
                thermostatsHeat.setHeatingSetpoint(maxTemp) // Set to heat
                log.info "HVAC ON, set heat: ${maxTemp}"
                sendMessageNotification("Low temperature $currentTemp, turning on HVAC heat")
            }
            if (heaters) {
                heaters.on()
                log.info "Heaters on"
                sendMessageNotification("High temperature $currentTemp, turning on heaters")
            }
        }
        else if ((currentTemp - lowTemp) >= threshold) { // Turn heat off
            if (thermostatsHeat) {
                thermostatsHeat.setHeatingSetpoint(minTemp) // Disable
                log.info "HVAC OFF, set heat: ${minTemp}"
                sendMessageNotification("Temperature increased $currentTemp, turning off HVAC")
            }
            if (heaters) {
                heaters.off()
                log.info "Heaters off"
                sendMessageNotification("Temperature increased $currentTemp, turning off heaters")
            }
        }
    }
}


def humidityHandler(evt) {
    log.debug "Humidity sensor change notification, name: ${evt.name}, value: ${evt.value}"

    // High humidity
    def highThreshold = 1 // Upper difference in humidity to turn on
    def lowThreshold = 5 // Lower difference in humidity to turn off
    def locationScale = getTemperatureScale()
    def maxTemp
    def minTemp
    if (locationScale == "C") {
        minTemp = 10 // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxTemp = 32 // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        log.trace "Location is in Celsius, MaxTemp $maxTemp, MinTemp $minTemp for thermostat"
    } else {
        minTemp = 50 // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxTemp = 90 // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        log.trace "Location is in Farenheit, MaxTemp $maxTemp, MinTemp $minTemp for thermostat"
    }

    if (humiditySensor) {
        def currentHumidity = humiditySensor.humidity
        log.trace("Humidity Sensor Current humidity: $currentHumidity%")

        if ((highHumidity - currentHumidity) >= highThreshold) { // Turn on
            if (modeMonitor && !modeMonitor.contains(location.mode)) { // Empty means all modes, only turn on if we are in a supported mode (turn off to avoid over heating/cooling even if not in active mode)
                log.warn "Current mode ${location.mode} is not in the list of operating modes $modeMonitor, skipping turning on"
                return
            }

            if (!checkSchedule(0, "A") && !checkSchedule(1, "A") && !checkSchedule(2, "A")) { // Check if we are within operating Schedule to turn things on
                log.warn "Out of operating schedules, skipping turning on"
                return
            }

            if (thermostatsDehumidify) {
                thermostatsDehumidify.setCoolingSetpoint(minTemp) // Set to cool
                log.info "Dehumidify HVAC ON, set cool: ${minTemp}"
                sendMessageNotification("High humidity $currentHumidity%, turning on HVAC cool")
            }
            if (dehumidifiers) {
                dehumidifiers.on()
                log.info "Dehumidifiers on"
                sendMessageNotification("High humidity $currentHumidity%, turning on dehumidifiers")
            }
        }
        else if ((highHumidity - currentHumidity) >= lowThreshold) { // Turn off
            if (thermostatsDehumidify) {
                thermostatsDehumidify.setCoolingSetpoint(maxTemp) // Disable
                log.info "Dehumidify HVAC OFF, set cool: ${maxTemp}"
                sendMessageNotification("Humidity reduced $currentHumidity%, turning off HVAC")
            }
            if (dehumidifiers) {
                dehumidifiers.off()
                log.info "Dehumidifiers off"
                sendMessageNotification("Humidity reduced $currentHumidity%, turning off Dehumidifiers")
            }
        }
    }
}

// Checks if we are within the current operating scheduled
// Inputs to the function are user (i) and schedule (x) (there can be multiple schedules)
// Preferences required in user input settings are:
// settings."userStartTime${x}${i}"
// settings."userEndTime${x}${i}"
// settings."userDayOfWeek${x}${i}"
private checkSchedule(def i, def x) {
    log.debug("Checking operating schedule $x for user $i")

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        log.error "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
        sendPush "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
    }

    def doChange = false
    Calendar localCalendar = Calendar.getInstance(timeZone);
    int currentDayOfWeek = localCalendar.get(Calendar.DAY_OF_WEEK);
    def currentDT = new Date(now())

    // some debugging in order to make sure things are working correclty
    log.debug "Current time: ${currentDT.format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Check if we are within operating times
    if (settings."userStartTime${x}${i}" != null && settings."userEndTime${x}${i}" != null) {
        def scheduledStart = timeToday(settings."userStartTime${x}${i}", timeZone)
        def scheduledEnd = timeToday(settings."userEndTime${x}${i}", timeZone)

        if (scheduledEnd <= scheduledStart) { // End time is next day
            log.debug "End time is before start time, assuming it is the next day"
            scheduledEnd = scheduledEnd.next() // Get the time for tomorrow
        }

        log.debug("Operating Start ${scheduledStart.format("EEE MMM dd yyyy HH:mm z", timeZone)}, End ${scheduledEnd.format("EEE MMM dd yyyy HH:mm z", timeZone)}")

        if (currentDT < scheduledStart || currentDT > scheduledEnd) {
            log.info("Outside operating time schedule")
            return false
        }
    }

    // Check the condition under which we want this to run now
    // This set allows the most flexibility.
    log.debug("Operating DOW(s): ${settings."userDayOfWeek${x}${i}"}")

    if(settings."userDayOfWeek${x}${i}" == null) {
        log.warn "Day of week not specified for operating schedule $x for user $i, assuming no schedule set, so we are within schedule"
        return true
    } else if(settings."userDayOfWeek${x}${i}".contains('All Week')) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Monday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.MONDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Tuesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.TUESDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Wednesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.WEDNESDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Thursday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.THURSDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Friday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.FRIDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Saturday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SATURDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Sunday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SUNDAY) {
        doChange = true
    }


    // If we have hit the condition to schedule this then lets do it
    if(doChange == true){
        log.info("Within operating schedule")
        return true
    }
    else {
        log.info("Outside operating schedule")
        return false
    }
}

private sendMessageNotification(message) {
    // Send notifications
    if (!message) {
        log.warn "No message to send, skipping notifications"
        return
    }
    
    if (location.contactBookEnabled) {
        log.debug "Sending message to $recipients"
        sendNotificationToContacts(message, recipients)
    } else {
        log.debug "SMS: $sms, Push: $push"
        sms ? sendText(sms, message) : ""
        push ? sendPush(message) : sendNotificationEvent(message)
    }
}

private void sendText(number, message) {
    if (number) {
        def phones = number.split("\\+")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy server"
    
    def appName = "Temperature and Humidity Management with Scheduling"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoyServer, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (!disableUpdateNotifications) {
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def caps = [ highTemperatureSensor, thermostatsCool, fans, lowTemperatureSensor, thermostatsHeat, heaters, humiditySensor, thermostatsDehumidify, dehumidifiers ]
                caps?.each {
                    def devices = it?.findAll { it.hasAttribute("codeVersion") }
                    for (device in devices) {
                        if (device) {
                            def deviceName = device?.currentValue("dhName")
                            def deviceVersion = ret.data?."$deviceName"
                            if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                                def msg = "New version of device ${device?.displayName} available: $deviceVersion, version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                                log.info msg
                                if (!disableUpdateNotifications) {
                                    sendPush(msg)
                                }
                            } else {
                                log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                            }
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}